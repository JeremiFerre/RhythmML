/*
 * generated by Xtext 2.14.0
 */
package fr.polytech.dsl.rhythm.serializer;

import com.google.inject.Inject;
import fr.polytech.dsl.model.rhythm.Battery;
import fr.polytech.dsl.model.rhythm.BatteryNote;
import fr.polytech.dsl.model.rhythm.CompositeNote;
import fr.polytech.dsl.model.rhythm.EmptyNote;
import fr.polytech.dsl.model.rhythm.Layer;
import fr.polytech.dsl.model.rhythm.Music;
import fr.polytech.dsl.model.rhythm.Piano;
import fr.polytech.dsl.model.rhythm.PianoNote;
import fr.polytech.dsl.model.rhythm.RhythmPackage;
import fr.polytech.dsl.model.rhythm.Section;
import fr.polytech.dsl.model.rhythm.Track;
import fr.polytech.dsl.rhythm.services.GuardinGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GuardinSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GuardinGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RhythmPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RhythmPackage.BATTERY:
				sequence_Battery(context, (Battery) semanticObject); 
				return; 
			case RhythmPackage.BATTERY_NOTE:
				sequence_BatteryNote(context, (BatteryNote) semanticObject); 
				return; 
			case RhythmPackage.COMPOSITE_NOTE:
				if (rule == grammarAccess.getCompositeBatteryNoteRule()) {
					sequence_CompositeBatteryNote(context, (CompositeNote) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCompositePianoNoteRule()) {
					sequence_CompositePianoNote(context, (CompositeNote) semanticObject); 
					return; 
				}
				else break;
			case RhythmPackage.EMPTY_NOTE:
				sequence_EmptyNote(context, (EmptyNote) semanticObject); 
				return; 
			case RhythmPackage.LAYER:
				if (rule == grammarAccess.getBatteryLayerRule()) {
					sequence_BatteryLayer(context, (Layer) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPianoLayerRule()) {
					sequence_PianoLayer(context, (Layer) semanticObject); 
					return; 
				}
				else break;
			case RhythmPackage.MUSIC:
				sequence_Music(context, (Music) semanticObject); 
				return; 
			case RhythmPackage.PIANO:
				sequence_Piano(context, (Piano) semanticObject); 
				return; 
			case RhythmPackage.PIANO_NOTE:
				sequence_PianoNote(context, (PianoNote) semanticObject); 
				return; 
			case RhythmPackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case RhythmPackage.TRACK:
				sequence_Track(context, (Track) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BatteryLayer returns Layer
	 *
	 * Constraint:
	 *     (notes+=BatteryNote | notes+=EmptyNote | notes+=CompositeBatteryNote)+
	 */
	protected void sequence_BatteryLayer(ISerializationContext context, Layer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BatteryNote returns BatteryNote
	 *
	 * Constraint:
	 *     noteType=BatteryNoteType
	 */
	protected void sequence_BatteryNote(ISerializationContext context, BatteryNote semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.BATTERY_NOTE__NOTE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.BATTERY_NOTE__NOTE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBatteryNoteAccess().getNoteTypeBatteryNoteTypeEnumRuleCall_1_0(), semanticObject.getNoteType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Battery returns Battery
	 *
	 * Constraint:
	 *     (name=EString? layers+=BatteryLayer+)
	 */
	protected void sequence_Battery(ISerializationContext context, Battery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeBatteryNote returns CompositeNote
	 *
	 * Constraint:
	 *     ((notes+=BatteryNote | notes+=EmptyNote)+ repeats=EInt)
	 */
	protected void sequence_CompositeBatteryNote(ISerializationContext context, CompositeNote semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositePianoNote returns CompositeNote
	 *
	 * Constraint:
	 *     ((notes+=PianoNote | notes+=EmptyNote)+ repeats=EInt)
	 */
	protected void sequence_CompositePianoNote(ISerializationContext context, CompositeNote semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyNote returns EmptyNote
	 *
	 * Constraint:
	 *     {EmptyNote}
	 */
	protected void sequence_EmptyNote(ISerializationContext context, EmptyNote semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Music returns Music
	 *
	 * Constraint:
	 *     (name=EString sections+=Section sections+=Section* tracks+=Track tracks+=Track*)
	 */
	protected void sequence_Music(ISerializationContext context, Music semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PianoLayer returns Layer
	 *
	 * Constraint:
	 *     (notes+=PianoNote | notes+=EmptyNote | notes+=CompositePianoNote)+
	 */
	protected void sequence_PianoLayer(ISerializationContext context, Layer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PianoNote returns PianoNote
	 *
	 * Constraint:
	 *     noteType=PianoNoteType
	 */
	protected void sequence_PianoNote(ISerializationContext context, PianoNote semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.PIANO_NOTE__NOTE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.PIANO_NOTE__NOTE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPianoNoteAccess().getNoteTypePianoNoteTypeEnumRuleCall_1_0(), semanticObject.getNoteType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Piano returns Piano
	 *
	 * Constraint:
	 *     (name=EString? layers+=PianoLayer+)
	 */
	protected void sequence_Piano(ISerializationContext context, Piano semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (name=EString tempo=EInt signature=EInt bars=EInt)
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.SECTION__TEMPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.SECTION__TEMPO));
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.SECTION__SIGNATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.SECTION__SIGNATURE));
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.SECTION__BARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.SECTION__BARS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSectionAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSectionAccess().getTempoEIntParserRuleCall_4_0(), semanticObject.getTempo());
		feeder.accept(grammarAccess.getSectionAccess().getSignatureEIntParserRuleCall_6_0(), semanticObject.getSignature());
		feeder.accept(grammarAccess.getSectionAccess().getBarsEIntParserRuleCall_8_0(), semanticObject.getBars());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Track returns Track
	 *
	 * Constraint:
	 *     (name=EString? (instrument=Battery | instrument=Piano))
	 */
	protected void sequence_Track(ISerializationContext context, Track semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
