/*
 * generated by Xtext 2.14.0
 */
package fr.polytech.dsl.rhythm.serializer;

import com.google.inject.Inject;
import fr.polytech.dsl.rhythm.Battery;
import fr.polytech.dsl.rhythm.BatteryNote;
import fr.polytech.dsl.rhythm.EmptyNote;
import fr.polytech.dsl.rhythm.Music;
import fr.polytech.dsl.rhythm.RhythmPackage;
import fr.polytech.dsl.rhythm.Section;
import fr.polytech.dsl.rhythm.Track;
import fr.polytech.dsl.rhythm.services.GuardinGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GuardinSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GuardinGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RhythmPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RhythmPackage.BATTERY:
				sequence_Battery(context, (Battery) semanticObject); 
				return; 
			case RhythmPackage.BATTERY_NOTE:
				sequence_BatteryNote(context, (BatteryNote) semanticObject); 
				return; 
			case RhythmPackage.EMPTY_NOTE:
				sequence_EmptyNote(context, (EmptyNote) semanticObject); 
				return; 
			case RhythmPackage.MUSIC:
				sequence_Music(context, (Music) semanticObject); 
				return; 
			case RhythmPackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case RhythmPackage.TRACK:
				sequence_Track(context, (Track) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BatteryNote returns BatteryNote
	 *
	 * Constraint:
	 *     noteType=BatteryNoteType
	 */
	protected void sequence_BatteryNote(ISerializationContext context, BatteryNote semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.BATTERY_NOTE__NOTE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.BATTERY_NOTE__NOTE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBatteryNoteAccess().getNoteTypeBatteryNoteTypeEnumRuleCall_1_0(), semanticObject.getNoteType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Battery returns Battery
	 *
	 * Constraint:
	 *     (name=EString? (notes+=BatteryNote | notes+=EmptyNote)+)
	 */
	protected void sequence_Battery(ISerializationContext context, Battery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyNote returns EmptyNote
	 *
	 * Constraint:
	 *     {EmptyNote}
	 */
	protected void sequence_EmptyNote(ISerializationContext context, EmptyNote semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Music returns Music
	 *
	 * Constraint:
	 *     (name=EString sections+=Section sections+=Section* tracks+=Track tracks+=Track*)
	 */
	protected void sequence_Music(ISerializationContext context, Music semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (name=EString tempo=EInt signature=EInt bars=EInt)
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.SECTION__TEMPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.SECTION__TEMPO));
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.SECTION__SIGNATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.SECTION__SIGNATURE));
			if (transientValues.isValueTransient(semanticObject, RhythmPackage.Literals.SECTION__BARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RhythmPackage.Literals.SECTION__BARS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSectionAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSectionAccess().getTempoEIntParserRuleCall_4_0(), semanticObject.getTempo());
		feeder.accept(grammarAccess.getSectionAccess().getSignatureEIntParserRuleCall_6_0(), semanticObject.getSignature());
		feeder.accept(grammarAccess.getSectionAccess().getBarsEIntParserRuleCall_8_0(), semanticObject.getBars());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Track returns Track
	 *
	 * Constraint:
	 *     (name=EString? instrument=Battery)
	 */
	protected void sequence_Track(ISerializationContext context, Track semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
